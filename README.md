# Zorkin: Self-Custodial Account Access with Zero-Knowledge Methods

<p align="center">
  <img src="./Logo.png" alt="Logo" style="max-height:200px;">
</p>

# Self-Custodial Account Access with Zero-Knowledge Proof of Corresponding OpenIdConnect OAuth2 Account Ownership

## Introduction


- Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge ([ZK-SNARKs](https://www.youtube.com/watch?v=gcKCW7CNu_M)) enable the creation of compact proofs that establish the ownership of certain data without revealing that data during the verification process.
- By employing ZK-SNARKs, we can securely confirm that a user holds a valid JSON Web Access Token (JWT) for an [OpenId Connect](https://openid.net/developers/how-connect-works/) OAuth2 account identified by an `OAuthAccountGUID`, while keeping the token's details confidential. The `OAuthAccountGUID` is a unique hash generated from three specific JWT fields: the issuer, audience, and subject, thereby uniquely identifying the account on the client side. This technology allows us to verify on the blockchain that a user possesses the OAuth2 account linked with the `OAuthAccountGUID`, which is essential for authorizing transactions. To prevent unauthorized access, and specifically to avoid the replaying of proofs that are visible on the blockchain, a value is introduced into a client definable JWT claim like the nonce (`CustomClaim`). The `CustomClaim` has a value that's taken as the hash combining a single-use public key and its expiration date. The associated private key is used to sign the transaction ID. This signature is then verified by checking it against the ephemeral key derived from the nonce's original hash, in conjunction with the proof. Using randomly generated public keys ensures that only the requester can provide a valid signature. Further enhancing security, a unique and random lease value is added to every transaction to guarantee that each transaction remains exclusively valid for a limited time, accompanied by a unique transaction ID.
- To reduce the transaction fees incurred during proof verification, we propose a rekeying system for a [logic signature](https://developer.algorand.org/docs/get-details/dapps/smart-contracts/smartsigs/modes/#contract-account) termed `SessionAccount`. The `SessionAccount` can be rekeyed to another instance containing the ephemeral public key and its expiration as template variables. The logic is designed to authorize transactions presented with either a signed transaction ID or a valid `OAuthAccountGUID` proof of ownership.
- The `SessionAccount` and the authorizing `SessionAccount` can be regenerated by querying the blockchain for the latest transaction using an [Indexer](https://developer.algorand.org/docs/get-details/indexer/), which enables access to the logic of the authorizing account. Similarly, we can recreate the base account using the `OAuthAccountGUID`, which is known post-login.
- To authenticate the JWT, an on-chain check against a cache of trusted JSON Web Keys (JWKs) is performed by a decentralized application (dApp). This cache is regularly and securely updated through decentralized HTTPS requests to the issuer's JWK endpoint, using a solution like [ChainLink](https://chain.link/). The information is then passed to blockchains such as Algorand using a bridge like [Wormhole](https://docs.wormhole.com/wormhole/quick-start/cross-chain-dev/).
- Transaction fees are managed through [fee pooling](https://developer.algorand.org/docs/get-details/transactions/#pooled-transaction-fees), which offers a frictionless experience for the user. This process is facilitated by a stateful smart contract called `FeeFunder`; however, details on its implementation are omitted for conciseness.
- Considering that SessionAccounts may be temporary due to the changing nature of OAuth2 client applications, we require decentralized account recovery at sign-up. For this, we use [ZK-Email](https://prove.email/) as the recovery method, enabling users to regain access to their accounts via proof of access to a recovery email sent initially at sign-up.
- Proof generation isn't compulsory at the first sign-in to the application and can be postponed until needed, such as when authorizing transactions outside an active session. This strategy reduces initial loading times and decreases prover server costs, as not all dApp visitors engage in transactions.
- Our Zorkin protocol advances beyond existing solutions like [Sui's ZK-Login](https://sui.io/zklogin) and [Snark-JWT-Verify](https://github.com/TheFrozenFire/snark-jwt-verify) by removing the need for a salting service, which could be a vulnerability if the salt database were compromised. A salting service doesn't address the risk of an OAuth2 provider querying accounts through the client, as they can technically issue arbitrary valid JWTs. Zorkin also minimizes the number of proof verifications required for transaction authorization by establishing an authorized session lasting several hours, thereby reducing gas fees. Moreover, proof generation is deferred until necessary, lightening server demands and improving user experience with faster loading times. Although Sui's ZK-Login was the pioneer in suggesting the use of the nonce field for account authorization, our work further innovates this concept.
- Future work includes refining the ZK-Email recovery method, limiting rekeying to only SessionAccounts connected to the OAuth account, exploring ways to decrease prover server load by increasing on-chain verification, and investigating how to smooth user interactions with [Opt-In](https://developer.algorand.org/docs/get-details/asa/#receiving-an-asset) and [Minimum Balance Requirement (MBR)](https://developer.algorand.org/docs/get-details/accounts/#minimum-balance) for asset creation.
- A comprehensive explanation of the Zorkin system, particularly the recursive rekeying process, is provided in the methods section.

We considered using a stateful dApp to manage session information by tracking details within the app's storage directly. However, this approach would complicate the system and raise operational costs. Thus, we opted for a simpler, stateless solution that prioritizes efficiency and effectiveness. While a stateful dApp might be employed in future updates, our present stateless method is performing satisfactorily.


## Method

The following provides a concise overview of the system. First we introduce the components to the solution, and later we describe protocols and procedures incorporating these procedures to achieve some of the functionality outlined in the introduction.

### Components of the Solution


#### JWTCircuit

The JWTCircuit is a ZK-SNARK circuit designed to relate the inputs together through equality constraints to assert that the JWT is signed with the specified RSA key, and the public input is a hash of the `OAuthAccountGUID`, nonce claim, and `RSAPublicKey`. `OAuthAccountGUID` is the hash of the issuer, audience and subject fields of the JWT.

```java
// The JWTCircuit's essential function is to confirm the validity of a private JWT key for a specific public identifier.
// MIMC7 and Poseidon denote cryptographic hashing algorithms.

JWTCircuit(private jwt, private RSAPublicKey, public publicInput):
  // Assert that the JWT has been signed with the provided RSA Public Key.
  assert RSAVerify(jwt, RSAPublicKey)
  // Utilize the Poseidon hash function to compute OAuthAccountGUID from issuer, audience, and subject claims in the JWT.
  OAuthAccountGUID = Poseidon(jwt.iss, jwt.aud, jwt.sub)
  Nonce = jwt.nonce
  // Deploy the MIMC7 hash function to calculate the public identifier (PublicInput) from OAuthAccountGUID, Nonce, and RSAPublicKey.
  PublicInput = MIMC7(OAuthAccountGUID, Nonce, RSAPublicKey)
  // Confirm that the computed PublicInput aligns with the publicInput supplied for verification.
  assert PublicInput == publicInput
```

The circuit, once compiled, manifests as a Groth16 ZK-SNARK proving system consisting of a verifier and a prover, using the BN254 elliptic curve for ECC. The verifier is described in terms of parameters referred to as `JWTVKey`. The verifier will verify proofs against a public input on-chain, along with the pre-image to the hash (`OAuthAccountGUID`, nonce, & `RSAPublicKey`). Successful verification, assuming replay attacks are prevented through signing with the ephemeral key specified in the nonce's pre-image, will prove that the sender is in possession of a JWT that was signed with the private key counterpart to the `RSAPublicKey` that grants access to the account uniquely identified by `OAuthAccountGUID`.

#### ProofVerifier

The `ProofVerifier` component functions as an on-chain logic signature designed to authenticate proofs supplied by the `JWTCircuit`-derived prover. Its primary role is to validate these proofs against specified public inputs, as well as the hash's pre-image components: `OAuthAccountGUID`, nonce, and `RSAPublicKey`. A successful verification demonstrates that the requesting party possesses a JWT authenticated by the corresponding private key of the `RSAPublicKey`. Consequently, this confirms their authorized access to the account identified by `OAuthAccountGUID`, assuming the absence of replay attacks whose mitigation is explained later.

Below is pseudocode for the `ProofVerifier` approval logic:
```python
# Define the hardcoded verification key based on JWTVKey parameters.
VKey = JWTVKey

def ProofVerifier(proof, publicInput):
    # Execute GROTH16 proof verification using the JWTVKey parameters
    # specifically tailored to our JWT circuit's verification needs.
    assert ProofIsValid(proof, publicInput, VKey)
```

In this implementation, the `ProofVerifier` function employs the GROTH16 verification algorithm, asserting the proof's validity predicated on the given public input and the statically defined `VKey`. It ensures that the proof meets all the verification criteria.

#### RSAVerifier

The `RSAVerifier` is a stateful smart contract on the blockchain which plays a pivotal role in maintaining the integrity of token authentication. It is tasked with the continuous updating of RSA public keys sourced from the JWKs (JSON Web Keys) endpoints of OAuth providers that support the OpenID Connect protocol. This updating process utilises secure multi-party computation mechanisms, ChainLink being an illustrative example.

Upon invocation, the `RSAVerifier` performs a crucial authentication check: it compares the RSA public key presented in a transaction against its cache of trusted keys. This cache represents the current set of valid keys from known OAuth providers. Should a public key not be listed within this set, the `RSAVerifier` will categorically reject the transaction, thereby preventing any fraudulent authentication attempts.

The code snippet presents two functions integral to the `RSAVerifier` smart contract: `UpdateCache` and `RSAVerifier` itself.

```python
def UpdateCache(VAAMessage):
  # Asserts the validity of the message received from Wormhole's core module
  assert Wormhole.Core.MessageIsValid(VAAMessage)
  # Updates the cache of RSA public keys with the newly received key
  UpdateCacheWithCurrentAuthenticRSAPK(VAAMessage.payload.newRSAPk)

def RSAVerifier(RSAPublicKey):
  # Verifies that the provided RSA public key is registered in the current cache
  assert RSAPkIsStoredInCache(RSAPublicKey)
```

In the provided code, the `UpdateCache` function is responsible for refreshing the smart contract's stored cache of RSA public keys. This function is called when a new public key is received from a verified `VAAMessage`—a message structure using Wormhole's infrastructure for data transport. The content of this message originates from a multi-party computation (MPC) system (such as Chainlink), which securely transmits the new RSA public key to the smart contract. Once the message is confirmed to be authentic by the `Wormhole.Core.MessageIsValid` check, the new key is added to the cache with the `UpdateCacheWithCurrentAuthenticRSAPK` call.

Additionally, the `RSAVerifier` function takes a given RSA public key—presented as part of a transaction—and checks against the contract's cache to confirm its presence using the `RSAPkIsStoredInCache` assertion. If the key is not found in the cache, indicating it is either outdated or unauthorized, the function will reject the transaction. This assertion acts as a safeguard, ensuring that only transactions with recognized and valid RSA public keys are processed, thus enhancing the robustness of authentication within the system.

#### FeeFunder

The `FeeFunder` is a stateful smart contract designed to facilitate the payment of transaction fees that occur during user authentication through fee-pooling. Zorkin's vision is that businesses utilizing this system will bear the transaction fees for their users, thereby simplifying onboarding. Specific details of `FeeFunder`'s implementation are yet to be disclosed.

#### SessionAccount

The `SessionAccount` is a Logic Signature Account that holds the user's assets. It's assumed that the authorizing address is always an instance of a SessionAccount with the same `OAuthAccountGUID`, but different authorizing session access parameters `epk` (ephemeral public key) that has private key `esk` and `exp` (expiry of the session).

Spending transaction authorization is granted by the approval logic if:
- The user provides a signature of the transaction Id signed with `esk` and isn't expired (i.e. `exp` < `Txn.lastValidity`), and it's post account creation (i.e. `epk` != `DefaultEphemeralKey`).
- The user submits a valid proof and public input, demonstrating access to the OAuth2 account identified by `OAuthAccountGUID`, and signs the transaction Id with the `newEpk` private key which is in the pre-image to the Nonce hash. A signature of the transaction Id by the private key of the `newEpk` is provided as an argument to the `SessionAccount` LSIG and is verified to prevent replay attacks.
\
\
Upon rekeying to a new authorizing `SessionAccount` with access to the initial account, the user is considered to be in an authorized session.

To mitigate replay attacks, verification incorporates signing with a one-time-use ephemeral key, as outlined by the nonce's pre-image. The verification key, labeled as `JWTVKey`, is embedded in the circuit and thus establishes a unique address correlating to the verification key parameters. This exclusivity permits subsequent transactions to verify that the characteristics of the verifier conform to those defined by `JWTVKey`.

```python
DefaultEphemeralKey = Bytes(16, "0xDEADBEEF")
Exp = TMPL('TMPL_EXP')
Epk = TMPL('TMPL_EPK')
OAuthAccountGUID = TMPL('TMPL_OAUTHACCOUNTGUID')
ProofVerifierAddr = "..." # Harcoded Address of the verifier LSIG
RSAVerifierAppId = "..." # Harcoded AppId of the RSA Verifier

def validJWTProof(sig):
    assert Txn.note == OAuthAccountGUID
    assert Txn.type == "rekey"
    assert Global.groupSize == 4
    assert Txn.groupIndex == 2
    # Get PublicInput Pre-Image parameters
    newEpk, expirationValidity, RSAPublicKey = Txn.note()
    # Verify RSA Public Key
    assert Gtxn[1].appId == RSAVerifierAppId
    assert Gtxn[1].appArgs[0] == "RSAVerifier"
    assert Gtxn[1].appArgs[1] == RSAPublicKey
    # Verify Proof & its correspondence to this SessionAccount
    Nonce = Sha256(newEpk, expirationValidity)
    PublicInput = MIMCHash(OAuthAccountGUID, Nonce, RSAPublicKey)
    assert Gtxn[0].sender == ProofVerifierAddr
    assert Gtxn[0].note == PublicInput
    assert ED25519_Verify(sig, Txn.id, newEpk)
    assert expirationValidity < Txn.lastValidity
    """
    ... and other assertions that: prove user posses an authentic valid JWT for an OAuth2 account uniquely identified 
    OAuthAccountGUID, and that the nonce delegated authority to the ephemeral key, that will ultimately grant access to the account
    for a Session (limited time) with the ephemeral private key.
    """

# LSIG Entry point
def SessionAccount(sig):
    assert fee == 0
    if Epk == DefaultEphemeralKey:
        # Base case, first time account creation
        assert validJWTProof(sig) 
    elif (ED25519_Verify(sig, Txn.id, EphemeralPK) and
          Exp < Txn.lastValidity): 
        # Session usage
        Approve()
    else:
        # Recursive case, rekeying
        assert validJWTProof()
```

#### SessionAccount Reproduction

When spending from a `SessionAccount`, the LSIG program code for both the account and its *authorizing* `SessionAccount` must be reproduced (see [Rekeying in Algorand](https://developer.algorand.org/docs/get-details/accounts/rekey/)). The spending account is the base account, while the authorizing account provides authorization.
\
\
Reproducing the base account involves creating a `SessionAccount` LSIG instance using the known `OAuthAccountGUID` value for the template variable and default values for the remaining variables.
\
\
Reproducing the authorizing account entails using an Indexer for efficient blockchain state querying to obtain the last transaction of the known authorizing address. This data is then used to create an authorizing `SessionAccount` LSIG instance with the relevant template variables.

```python
DefaultEphemeralKey = Bytes(16, "0xDEADBEEF")
def GetBaseAccount(OAuthAccountGUID):
  return SessionAccount({TMPL_OAUTHACCOUNTGUID: OAuthAccountGUID, TMPL_EPK: DefaultEphemeralKey, TMPL_EXP: 0})})

def GetAuthorizingAccount(OAuthAccountGUID):
  # Get the last transaction of the authorizing address
  baseAccount = GetBaseAccount(OAuthAccountGUID)
  authorizingAddress = baseAccount['auth-addr']
  lastAuthTxn = Indexer.GetLastTxn(authorizingAddress)
  if lastAuthTxn == None:
    return GetBaseAccount(OAuthAccountGUID)
  # Get the template variables from the last transaction
  epk, exp = ReadTemplateVariables(lastAuthTxn)
  return SessionAccount({TMPL_OAUTHACCOUNTGUID: OAuthAccountGUID, TMPL_EPK: epk, TMPL_EXP: exp})

def GetSessionAccount(OAuthAccountGUID):
  return [GetBaseAccount(OAuthAccountGUID), GetAuthorizingAccount(OAuthAccountGUID)]

def GetNewAuthorizingSessionAccount(OAuthAccountGUID, newEpk, newExp):
    return SessionAccount({TMPL_OAUTHACCOUNTGUID: OAuthAccountGUID, TMPL_EPK: newEpk, TMPL_EXP: newExp})
```

### Account Creation

When a user first creates a SessionAccount account, they reproduce the SessionAccount where the authorizing account must match the base account as it is yet to be rekeyed. To create a new authorized session wherein they can spend from the account with a temporary ephemeral signing key, they must first prove access to the corresponding OAuth2 account identified by `OAuthAccountGUID` that delegates temporary spending authority to their specified ephemeral key as explained in the next Section.


### Authorize a new Session

The process involves rekeying a base SessionAccount to a new, time-limited authorizing SessionAccount. This authorizing account permits spending from the base account to anyone with the bounded ephemeral private key, verified by signing the transaction Id. To authorize this rekeying, one must prove possession of a valid JWT OAuth access token linked to the `OAuthAccountGUID` identifiable OAuth2 account. This token should detail the ephemeral public key and the expiration (validity rounds) of the new authorizing SessionAccount in the nonce's pre-image.
\
\
The procedure is the following:
1. Create a new ED25519 keypair for the ephemeral key, with the public key `newEpk` and private key `newEsk`. Specify the expiration validity of the new authorizing SessionAccount as `newExp`.
2. Request a JWT from the OAuth2 provider, such as Google, using the OAuth2 OpenIDConnect protocol, with a nonce of `Sha256(newEpk, newExp)`. The JWT should be signed with the RSA public key `RSAPublicKey` of the OAuth2 provider.
3. Derive the `OAuthAccountGUID` as `Poseidon(jwt.iss, jwt.aud, jwt.sub)`, where `jwt.iss` is the OAuth2 provider identifier, `jwt.aud` is the OAuth2 client identifier, and `jwt.sub` is the OAuth2 user identifier.
4. Provide private the JWT and `RSAPublicKey` as private inputs and the public input as `MIMCHash(OAuthAccountGUID, RSAPublicKey, Nonce)` to the prover. The prover will return a `proof` and public input `publicInput`, if the proof is valid.
5. Reproduce the base SessionAccount and its authorizing SessionAccount using the `OAuthAccountGUID` by calling the `GetSessionAccount` function.
6. Create a new Authorizing SessionAccount with the `newEpk` and `newExp` using the `GetNewAuthorizingSessionAccount` function, which will be used to rekey the base SessionAccount.
7. Submit a transaction group, called a Session Authorizing Transaction, with the following transactions:
    - Transaction 0: An application call to `FeeFunder`, to cover fees associated with the transaction group. `FeeFunder` according to a condition, such as being from a client that's a registered user of Zorkin.
    - Transaction 1: A self-payment of 0 to the `ProofVerifier` with the `proof` input arguments (the `publicInput` is specified in the note for communication to other transactions in the group).
    - Transaction 2: An application call to `RSAVerifier` with the `RSAPublicKey` provided as an application argument.
    - Transaction 3: A rekey of the base SessionAccount to the new authorizing SessionAccount, signed by the current authorizing account. The inputs are the nonce pre-image (`newEpk` and `newExp`), and a signature of the transaction Id by `newEsk`. A random lease value is provided to ensure the transaction Id is unique, and to prevent replay attacks even for the same transaction.

The due to the atomic property of the transaction: the proof is valid, the `RSAPublicKey` is authentic, and the `newEpk` and `newExp` are valid for the `OAuthAccountGUID` and `RSAPublicKey` respectively. If the transaction is approved, the base SessionAccount will be rekeyed to the new authorizing SessionAccount, and the user will be able to spend from the account with the `newEsk` private key until the `newExp` validity rounds have passed.

![CredentialCreation](./images/AuthorizingASession.png)


### Spending within an Authorized Session

Once a user has authorized a new session, they can spend from the account with the `newEsk` private key until the `newExp` validity rounds have passed by providing a signature of the transaction Id by `newEsk` as an argument to the `SessionAccount` LSIG. The base SessionAccount and Authorizing SessionAccount are reproduced as explained in the previous section. Additionally the lease field is set to a random value each time, to ensure the transaction Id is unique and prevent replay attacks even for the same transaction.

1. Reproduce the base SessionAccount and its authorizing SessionAccount using the `OAuthAccountGUID` by calling the `GetSessionAccount` function.
2. Sign a spending transaction, after assigning a random value to the lease field, with the the authorizing SessionAccount with an argument of the transaction Id signed by `newEsk`.
3. Add the transaction to a group transaction that includes an application call to `FeeFunder`, which will cover transaction fees through fee pooling.
4. Submit the transaction to the network.


![NativeGeneral](./images/SigningInASession.png)


### Account Recovery

To simplify, account recovery in Zorkin, not previously mentioned, involves adding a recovery factor to the SessionAccount for access restoration, like if a client goes offline. A proposed recovery method is using [ZK-Email](https://prove.email/) to send a recovery email at account creation. The user then verifies access to this email, linked to the SessionAccount through elements like the DKIM email signature RSA public key and their email address as template variables.

### Proof Generation Deferral

Proof generation by a remote prover, which can be resource-intensive, is postponed until required for signing to optimize costs and loading times. This enhances user experience, as many dApp users, like those browsing an NFT marketplace, don't immediately transact. Once generated, a proof needs only a single verification for session establishment (i.e., rekeying), allowing subsequent spending without further proof production or verification until expiration, thereby reducing authentication fees and prover server costs.

## Comparison with Existing Work & Differentiation

- In similar work, reliance on an external service for storing salt values is common, creating a central point of failure where loss of these values can lead to loss of account access. Our approach eliminates this dependency, but introduces the potential for OAuth2 providers to reproduce accounts by enumerating identifiers. Despite this, OAuth2 providers can still identify linked contract accounts, even with salting, if they are aware of the client. They can achieve this by querying the frontend, leveraging their ability to generate valid JSON Web Tokens (JWTs) as the OAuth2 provider.

- Zero-Knowledge (ZK) account recovery, such as ZK-Email, is essential due to the temporary nature of OAuth2 clients and the frequent replacement of client IDs and secrets in applications. This recovery method avoids dependence on centralized infrastructure, offering options like proof of email access or using another Web3 wallet. Zorkin plans to implement ZK-Email recovery as a subsequent step to this proposal.

- Only one proof generation and verification is needed to establish an authorized session through authorization of the ephemeral key to spend from the account post-rekey. Transactions within an authorized session only require use of the bounded ephemeral key, eliminating fees involved in proof verification.

- Session creation and proof generation are postponed until the user signs, aligning with transaction intent and reducing loading times and server costs, which is practical since users often browse without transacting. This reduces the perceived loading times while a user authenticates, which is important for user experience.

## Future Work

We plan to enhance our methodology with the following initiatives:

1. Improve the Zero-Knowledge Email (ZK-Email) recovery process.
2. Ensure rekeying is only permitted for SessionAccount instances associated with the same OAuth account, to enhance security.
3. Explore strategies for offloading computation from the prover server by increasing the use of on-chain verifications.
4. Investigate methods to streamline the user experience, particularly with regards to the Algorand 'Opt-In' procedure for receiving an asset and addressing issues related to the Minimum Balance Requirement (MBR) that is necessary when opting in to receive an asset on the Algorand blockchain.

We have already established a technique for restricting rekeying. This approach involves generating the program code on-chain by inputting the specific parameters during a rekey transaction. This code is then hashed to generate an address. By comparing this address with the address in the rekey field, we can confirm if the rekeying is targeting a legitimate session account.

## Contribution Statement

Authored by Winton Nathan-Roberts of Sydney, Australia, this document details original work distinct from existing literature to the best of my knowledge. Novel contributions include its approach in implementing OAuth2 self-custodial access by recursively regenerating and rekeying SessionAccount LSIGs, the elimination of a salting service, proof generation deferral, decentralized recovery options and reduction in gas fees associated with constant proof verification. Thanks to the Algorand community for their support.
\
\
All Rights Reserved with Copyright.

## Disclaimer

This content, including texts, graphics, code, etc., is for informational purposes and provided 'as is' without guarantees.

- NO WARRANTIES: We offer no warranties or guarantees, explicit or implied.
- NO LIABILITY: We are not liable for any damages from using or inability to use this content.
- INDEPENDENCE: We do not necessarily have a direct affiliation with any party mentioned or implied besides Zorkin.
- INDEMNIFICATION: You must defend and indemnify us against all claims and damages from your use of the content.
- NOT PRODUCTION READY: The content may have vulnerabilities and is not for production use.
- USE AT YOUR OWN RISK: You are solely responsible for using the content and ensuring its legal compliance.
- UNVERIFIED CLAIMS: Claims in the content are not independently verified; do your own research before relying on them.

This disclaimer is applied to the fullest extent permitted by law. By using the content, you accept these terms. Note: This disclaimer was assisted by AI and I am not a legal professional. TLDR: it's an idea and an MVP, that I may or may not continue to work on at my discretion. Everything is subject to change, including the name.
