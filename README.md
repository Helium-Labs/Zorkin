# Zorkin: Self-Custodial Account Access with Zero-Knowledge Methods

<p align="center">
  <img src="./Logo.png" alt="Logo" style="max-height:200px;">
</p>

# Self-Custodial Account Access with Zero-Knowledge Proof of Corresponding OpenIdConnect OAuth2 Account Ownership

## Introduction
#### About ZK-SNARKs
- Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge (ZK-SNARKs) are advanced cryptographic tools that allow one party (the prover) to prove to another party (the verifier) that it possesses certain information without revealing the information itself. These proofs are remarkably small, making them quick to verify even on a blockchain, and they don’t require any interaction between the prover and verifier beyond the initial proof transmission.

#### Proving OAuth Account Ownership while preserving privacy

- Using ZK-SNARKs, it is possible to verify that a user has a valid JSON Web Access Token (JWT) for an account managed by OpenID Connect, which is a layer on top of the OAuth 2.0 protocol framework. This is done without exposing any sensitive token details. By combining specific fields from the JWT – issuer, audience, and subject – a unique identifier, the `OAuthAccountGUID`, can be generated, which represents the account in a privacy-preserving way. In a blockchain setting, ZK-SNARKs allow us to authenticate that the user is indeed linked to the `OAuthAccountGUID` without exposing the JWT or OAuth 2.0 credentials. This authentication is essential for secure transaction authorization. To enhance security and thwart replay attacks, a nonce (a number used once) is encoded within a user-definable claim of the JWT like the nonce claim (`CustomClaim`); it is generated by hashing a one-time-use ephemeral public key (`epk`) and a timestamp at which key expires. The corresponding private key (`esk`) signs a the transaction identifier, and this signature, along with the proof and hash pre-images, are given to the blockchain's verifier. This verification process ensures that only the rightful OAuth account owner, possessing the correct private key, can authorize transactions linked to the `OAuthAccountGUID`. All transactions have a unique lease value to prevent replay attacks, even within their respective validity range.

#### Authorizing a Session to Transact without additional Proof Verifications

- Once ownership of the `OAuthAccountGUID` is established, the ephemeral (temporary) key and its expiration timestamp can be used to control access to a secure session. In this session, the private key holder can approve further transactions using the same method without needing to generate new proofs or verifications. To facilitate this, a Logic Signature contract account called a `SessionAccount` is used. This `SessionAccount` has template variables for the ephemeral public key (`epk`), the expiration time (`exp`), the `OAuthAccountGUID` and the name of the  key for the `CustomClaim`. It contains logic that allows transaction approvals in line with the criteria defined above. The `CustomClaim` template variable is set to a value that will be used for the lifetime account, with a default value of 'nonce'. Initially, `SessionAccount` has placeholder values for `epk`, `exp` and only validates transactions providing proof of `OAuthAccountGUID` access. To establish an authorized session, `SessionAccount` is rekeyed to a new instance with the actual ephemeral public key and expiration time set for `epk` and `exp`. Subsequent transactions are approved if they either show proof of `OAuthAccountGUID` ownership or provide a valid signature of the transaction ID created with the private key corresponding to `epk`, provided the current time is before the session's expiration time (`exp`).

- Both the `SessionAccount` used for initial authorization and the session-enabling `SessionAccount` can be reconstructed without absolute reliability with only the `OAuthAccountGUID`. This is done by consulting the blockchain's transaction history using an indexer, which is a tool designed to query blockchain data efficiently. With the latest transaction data at hand, one can extract the logic governing the authorizing account. Likewise, the base `SessionAccount`, which is setup after the user logs in using the `OAuthAccountGUID`, can be recreated whenever necessary.

#### Ensuring JWT Authenticity

- To ensure that a JSON Web Token (JWT) is authentic, a decentralized application (dApp) checks it against a list of trusted JSON Web Keys (JWKs). This list is maintained on the blockchain and is periodically updated securely by importing fresh data from the issuer's JWK endpoint. The updates occur through a multi-party computation (MPC) process involving a decentralized service like ChainLink, which securely aggregates information from different external sources. Once the JWKs are fetched, they can be conveyed to various blockchains using a cross-chain interoperability protocol, such as Wormhole, which acts as a bridge, transferring and translating information between different blockchain networks, like Algorand.

- To improve user convenience, transaction fees are covered using a fee pooling mechanism. This approach allows transaction costs to be sponsored by a dedicated account or pool, removing the need for individual users to pay fees for each transaction. This task is managed in the background by a specialized stateful smart contract known as `FeeFunder`. While the internal workings of `FeeFunder` are beyond the scope of this summary, it is designed to facilitate fee payments on behalf of users, contributing to a seamless transaction experience.

#### Account Recovery

- Given that the association between a user and an OAuth2 client application can change over time, it is crucial to have a reliable and decentralized method for account recovery. To address this, the recovery mechanism, ZK-Email, is leveraged at the time of user registration. Using ZK-Email, if a user loses access to their account, they can prove ownership by demonstrating that they have access to a specific recovery email address that was initially used during the sign-up process. ZK-Email utilizes zero-knowledge proof technology to allow users to authenticate their email ownership without revealing sensitive information.

#### Authorized Session Revocation

The SessionAccount has a template variable for a public key of a key held by the user of the Zorkin service, which allows them to revoke any active session by rekeying the SessionAccount back to the base SessionAccount. This is useful in the event of SessionAccount loss of access for any reason, such as a malicious takeover or simply as a safety measure to prevent long range attacks that might utilise an old unexpired Session key.

#### Proof Generation Deferral

- The requirement for users to generate cryptographic proofs is deferred until such an action is necessary, for example when approving transactions without an active session. By postponing proof generation until it's explicitly required, the application can provide a more responsive initial login experience. Additionally, this strategy can lead to cost savings for the dApp's operators, as the computational expense of creating proofs is incurred only for users who go on to engage in activities like transactions that necessitate such proofs. This can notably reduce the burden on servers tasked with proof generation, aligning resource use with actual dApp interaction.

#### Differentiation & Improvements to Existing Work

- Zorkin advances the state of similar authentication technology in several ways when compared to existing solutions such as Sui's ZK-Login and the Snark-JWT-Verify library. Here are the key improvements made by Zorkin more clearly explained:

1. **Elimination of Salting Service Dependency**: Zorkin removes the dependency on a salting service for security purposes. Salting services add a layer of complexity and pose a potential vulnerability; if the salting service is compromised, it could lead to the loss of access to accounts. Furthermore, relying solely on a salting service does not mitigate the risk associated with an OAuth2 provider directly accessing accounts, as they have the authority to issue valid JWTs by design.

2. **Reduced Proof Verifications**: Another significant enhancement Zorkin offers is minimizing the frequency of proof verifications required for transaction authorization. By creating a trusted session that lasts for several hours, users do not need to generate new proofs for every transaction during that session. This reduction in verification needs leads to lower transaction fees and a smoother user experience.

3. **Deferred Proof Generation**: In line with providing a better user experience, Zorkin defers the generation of cryptographic proofs until the point when they are actually needed, such as when authorizing transactions. This approach relieves the server from the computational demands of generating proofs for every user upon log-in, especially beneficial when many users may not engage in transactions immediately. By deferring this intensive process, Zorkin ensures faster application loading times and optimizes resource utilization.

4. **Enhanced Flexibility with Authentication Providers**: Existing systems often depend on the ability to define a 'nonce' claim during the OAuth2 request to set up the ephemeral key. This presents a limitation because not all authentication solutions—like Firebase—allow programmatic control over user-definable claims. Zorkin's implementation uses a `CustomClaim`, which is a more flexible approach that is not restricted to a specific claim like 'nonce'. Hence, Zorkin's design allows it to work with a broader range of authentication providers that may not offer the same level of claim customization.

5. **Revocation of Active Sessions**: Zorkin allows users to revoke any active session by rekeying the SessionAccount back to the base SessionAccount, either using the ephemeral key itself, or remotely making use of the hardcoded creator public key which allows only the creator to revoke the session. This is useful in the event of SessionAccount loss of access for any reason, such as a malicious takeover or simply as a safety measure to prevent long range attacks that might utilise an old unexpired Session key.

These improvements focus on enhancing security, reducing costs, and offering a more adaptable and user-friendly Zero-Knowledge self-custodial authentication mechanism suitable for a variety of applications and authentication services.

## Method

The following provides a concise overview of the system. First we introduce the components to the solution, and later we describe protocols and procedures incorporating these procedures to achieve some of the functionality outlined in the introduction.

### Components of the Solution


#### JWTCircuit

The JWTCircuit is a ZK-SNARK circuit designed to relate the inputs together through equality constraints to assert that the JWT is signed with the specified RSA key, and the public input is a hash of the `OAuthAccountGUID`, `CustomClaimValue`, `RSAPublicKey`, and `OAuthClientEntry`. `OAuthAccountGUID` is the hash of the issuer and subject fields of the JWT, uniquely identifying the users account on the issuers platform. `OAuthClientEntry` is a unique identifier of the particular key of the `CustomClaim` used to specify the ephemeral key and its expiration on an interfacing OAuth client on the issuer that authenticates users into their application with OpenIdConnect.

```java
// JWTCircuit's primary role is to validate the correctness of the private JWT key for its corresponding public identifier.
// MIMC7 and Poseidon are hashing algorithms.
JWTCircuit(private jwt, private RSAPublicKey, private CustomClaimKey, public publicInput):
  // Ensure the JWT is signed with the provided RSA Public Key.
  assert RSAVerify(jwt, RSAPublicKey)
  // Use Poseidon hash to obtain OAuthAccountGUID from JWT's issuer and subject.
  OAuthAccountGUID = Poseidon(jwt.iss, jwt.sub)
  // Retrieve the value associated with the CustomClaimKey from the JWT.
  CustomClaimValue = jwt[CustomClaimKey]
  // Establish a unique identifier for a particular OAuth client based on the issuer's information.
  OAuthClientEntry = Poseidon(jwt.iss, jwt.aud, CustomClaimKey)
  // Utilize MIMC7 hash to compute the public identifier (publicInput) from OAuthAccountGUID, CustomClaimValue, RSAPublicKey, and OAuthClientEntry.
  PublicInput = MIMC7(OAuthAccountGUID, CustomClaimValue, RSAPublicKey, OAuthClientEntry)
  // Check that the computed PublicInput matches the provided public input.
  assert PublicInput == publicInput
```

Upon compilation, the circuit becomes part of a Groth16 ZK-SNARK proving system, comprising a verifier and a prover that utilize the BN254 elliptic curve. The verifier operates based on parameters identified as `JWTVKey`, verifying proofs against on-chain public input and the accompanying pre-image hash elements (`OAuthAccountGUID`, `CustomClaimValue`, `RSAPublicKey`, `OAuthClientEntry`). Assuming protection against replay attacks via the signing ephemeral key specified in `CustomClaimValue`, successful proof verification confirms the sender possesses a JWT authenticated with the private counterpart of `RSAPublicKey`, and that the user is distinctly identified by `OAuthAccountGUID`, authorizing through the OAuth client uniquely denoted by `OAuthClientEntry`, where the ephemeral key and its expiry are articulated in the `CustomClaimValue` under `CustomClaimKey`.

#### ProofVerifier

The `ProofVerifier` is a logic signature, purposed for verifying proofs provided by a `JWTCircuit`-based prover. The verifier is described in terms `JWTVKey`, its verification parameters. It verifies these proofs against the public input given in the note; proving account access through a JWT for the user identified by `OAuthAccountGUID` accessed through the OAuth client identified by `OAuthClientEntry`,

The pseudocode of the verification logic:
```python
# Establish the verification key using parameters from JWTVKey.
VKey = JWTVKey

def ProofVerifier(proof):
    # Ensure the transaction fee is zero to prevent exploitation through fee depletion.
    assert Txn.fee() == 0
    # Apply the GROTH16 verification algorithm with JWTVKey parameters
    # that are specifically crafted for our JWT circuit verification requirements.
    publicInput := Txn.note()
    assert ProofIsValid(proof, publicInput, VKey)
```

#### RSAVerifier

The `RSAVerifier` is an application that checks if an RSA public key is in a cache of JSON Web Keys (JWKs) from an issuer's endpoint, used for signing JSON Web Tokens (JWTs). This is done through its `ValidateOAuthRSAPublicKey` function, primarily to verify JWT authenticity. While it initially focuses on a single issuer, it can be extended to multiple issuers using 'BoxStorage'. To reduce costs, the JWK cache is updated infrequently via the `UpdateOAuthJWKSCache` function, with updates sourced through the Wormhole Bridge from a Chainlink-like Multi-Party Computation (MPC) solution.

```python
# State management using BoxStorage, a construct analogous to Algorand's key-value pair storage
BoxStorage issuerRSAPublicKeys
string issuer
string MPCHTTPSClientAddress
string MPCHTTPSClientChain

# Function to update the session data for an existing SessionAccount
def ValidateOAuthRSAPublicKey(RSAPublicKey):
  # Ensure that the RSA public key matches one of the keys provided by the issuer
  assert issuerRSAPublicKeys[issuer].has(RSAPublicKey)

# Function to update the cache of RSA public keys for the OAuth issuer
def UpdateOAuthJWKSCache(VAAMessage):
  # Verify the message's validity from Wormhole's core module
  assert Wormhole.Core.MessageIsValid(VAAMessage)
  # Check if the sender and source chain match the expected MPC HTTPS client and chain
  assert VAAMessage.sender == MPCHTTPSClientAddress
  assert VAAMessage.source_chain == MPCHTTPSClientChain
  # Update the JWK cache with the new set of keys from the message
  keys := VAAMessage.keys
  issuer := VAAMessage.issuer
  issuerRSAPublicKeys[issuer] = keys
```

#### TenantAuth Application

The `TenantAuth` verifies that users authorizing a new SessionAccount are authenticated with a registered Client Id from a supported issuer. It checks the ephemeral public key and its expiration in the `CustomClaimValue` under `CustomClaimKey`. Uniqueness is maintained by `OAuthClientEntry`, a Poseidon hash of the issuer, audience fields of the JWT, and `CustomClaimKey`. Only the creator of the `TenantAuth` app, typically a Zorkin user, can register an `OAuthClientEntry`. A special contract, `FeeFunder`, covers authentication fees, funded by the Zorkin user who established the `TenantAuth`.

##### TenantAuth Application
```python
BoxStorage OAuthClientEntrys
string ProofVerifierAddr # Hardcoded Address of the verifier LSIG
string RSAVerifierAppId # Hardcoded App ID of the RSA Verifier

# Add a new description of an OAuth client, that's for a specific issuer using an specific interfacing clientId
# Specified as the Poseidon hash of the clientId, issuer and CustomClaimKey
def AddNewOAuthClientDescriptor(OAuthClientEntry):
  # Assert only the creator is registering new OAuth clients
  assert Txn.sender == AppParam.creator()
  OAuthClientEntrys.add(OAuthClientEntry)

# Approve a SessionAuthorization, if the sender can prove access to registered OAuth client
def ApproveSession():
  # Assert the Txn is a part of a group of 4 transactions, representing an attempt to create an authorized session
  assert Txn.group_size == 4
  # Get the transaction from the base SessionAccount in the 3rd slot
  baseSessionAccountTxn := Gtxn[3]
  # Get the pre-image parameters from the transaction note
  Epk, Exp, RSAPublicKey, OAuthAccountGUID, OAuthClientEntry = baseSessionAccountTxn.note()
  # Create the expected CustomClaimValue from the pre-image parameters
  CustomClaimValue = Sha256(Epk, Exp)
  # Create the expected public input from the pre-image parameters
  PublicInput = MIMCHash(OAuthAccountGUID, CustomClaimValue, RSAPublicKey, OAuthClientEntry)
  # Assert the verifier is the correct verifier, with address ProofVerifierAddr which will uniquely identify the VKey parameters used to verify the proof
  proofVerifierTxn := Gtxn[1]
  assert proofVerifierTxn.sender == ProofVerifierAddr
  # Assert it the verifier is verifying a proof against the expected public input
  assert proofVerifierTxn.note() == PublicInput
  # Assert the interfacing OAuth client with ephemeral key and expiration parameters specified through the CustomClaim with key CustomClaimKey is registered (i.e. a client you have established)
  assert OAuthClientEntrys.has(OAuthClientEntry)

  # Verify the RSA key that signed the JWT is valid, by asserting that the RSAVerifier application is in the group which will verify the RSA public key authenticity
  RSAVerifierTxn := Gtxn[2]
  assert RSAVerifierTxn.appId == RSAVerifierAppId
  assert RSAVerifierTxn.application_args[0] == "ValidateOAuthRSAPublicKey"
  assert RSAVerifierTxn.application_args[1] == RSAPublicKey

# Revoke Session function, which can only be called by the creator of the TenantAuth application to authorize a rekey
# of a SessionAccount back to its base state, ending any authorized session.
def RevokeSession():
  # Only the Tenant creator, i.e. a Zorkin user, can revoke a session
  assert Txn.sender == AppParam.creator()
  # Assert in a group of two transactions
  assert Txn.group_size == 2
  # Assert the second transaction in the group is a rekey of the SessionAccount back to its base state.
  assert Gtxn[1].type == "rekey"
  assert Gtxn[1].rekeyTo == Gtxn[1].sender
```

##### FeeFunder LSIG

The `FeeFunder` is specifically designed so anyone can use it to invoke the `ApproveSession` function of the `TenantAuth` application, covering fees for the entire group transaction involved in creating a new authorized session.

```python
TenantAuthAppId = TMPL('TMPL_TENANTAUTHAPPID')

def FeeFunder():
  # Assert the Txn is an application call to TenantAuthAppId smartcontract
  assert Txn.appId == TenantAuthAppId
  # Assert the Txn is calling the RegisterSessionAccount function
  assert Txn.application_args[0] == "ApproveSession"
  sessionAccountAddr := Txn.application_args[1]
  # Assert the FeeFunder is covering the fees of the Session authorizing transaction group  
  assert Txn.fee() == 4 * Global.MinTxnFee
```


#### SessionAccount

The SessionAccount is a Logic Signature Contract Account designed to secure users' assets and manage certain authentication steps in creating and using sessions with an ephemeral key. It primarily handles four scenarios:

1. **Revoking Session Access**: The SessionAccount can be reset to its original state, effectively revoking access to an active session. This action can be initiated remotely by the creator of the TenantAuth application.

2. **Creating an Authorized Session**: When a user establishes a new session, the SessionAccount is reconfigured with a new ephemeral key and expiration parameters, as defined in the JWT's `CustomClaim`. This occurs after the user validates their access to the associated OAuth account (identified by `OAuthAccountGUID`) and the OAuth client (specified by `OAuthClientEntry`).

3. **Transacting in an Authorized Session**: The SessionAccount allows transactions during an active session, provided they are verified with the ephemeral key (`EpkTemplate`) and occur before its expiration (`ExpTemplate`).

4. **Handling the Base Case**: In situations where the SessionAccount being authorized and the base SessionAccount are the same, transactions are only approved if they are authenticated through the OAuth account (identified by `OAuthAccountGUID`) and the OAuth client (indicated by `OAuthClientEntry`).


```python
# Define constants and templates.
DefaultEphemeralKey = Bytes(16, "0xDEADBEEF")
ExpTemplate = TMPL('TMPL_EXP')
EpkTemplate = TMPL('TMPL_EPK')
OAuthAccountGUIDTemplate = TMPL('TMPL_OAUTHACCOUNTGUID')
TenantAuthAppId = TMPL('TMPL_TENANTAUTHAPPID')

# Assert the Tenant is attempting to revoke the ephemeral key, ending the authorized session.
# By rekeying the SessionAccount to the base SessionAccount.
def tenantIsRevokingSession():
    # Assert the Gtxn[0], the application call to the tenant, is specifically.
    # Assert there's two transactions in the group; and the first is an application call to the TenantAuth application.
    # And that it's specifically to the function "RevokeSession".
    assert Txn.groupSize == 2
    assert Gtxn[0].type == "appl"
    assert Gtxn[0].appId == TenantAuthAppId
    assert Gtxn[0].appArgs[0] == "RevokeSession"

    assert Txn.type == "rekey"
    # Tnx.sender is the address of the initial SessionAccount, i.e. the underlying address
    assert Txn.rekeyTo == Txn.sender
    # Assert the fee is 0, and covered by the tenant.
    assert Txn.fee() == 0

def hasOAuthAccountAccess(sig):
    # Validate this transaction is in a group with a TenantAuth application to ApproveSession
    # ApproveSession will handle the verification of the proof and public input.
    assert Gtxn[0].type == "appl"
    assert Gtxn[0].appId == TenantAuthAppId
    assert Gtxn[0].appArgs[0] == "ApproveSession"

# Entry point for LSIG (Logic Signature) execution.
def SessionAccount(sig):
    """
    Main function representing the Logic Signature for the SessionAccount.

    This function determines whether a transaction is approved based on the session state.
    """
    # Case: Revocation of any active session to the base account
    if Gtxn[0].appId == TenantAuthAppId:
        # Assert the creator is only attempting to revoke any active session
        assert tenantIsRevokingSession()

    # Case: Base state, representing first session creation
    elif EpkTemplate == DefaultEphemeralKey:
        # Rekeying to authorize a new SessionAccount as the authorizing address has fees covered by an external FeeFunder account.
        assert Txn.fee() == 0
        # Validate the sender has access to the corresponding OAuth account, and that proof replay attacks are prevented. 
        assert hasOAuthAccountAccess(sig) 

    # Case: Using an active session (Session usage).
    elif (ED25519_Verify(sig, Txn.transaction_id, EpkTemplate) and
          ExpTemplate < Txn.last_valid_round): 
        # Approve the transaction if it is signed by the ephemeral key and within the session validity.
        Approve()

    # Case: Rekeying to a new SessionAccount to authorize a new session.
    else:
        # Rekeying to authorize a new SessionAccount as the authorizing address has fees covered by an external FeeFunder account.
        assert Txn.fee() == 0
        # Validate the sender has access to the corresponding OAuth account, and that proof replay attacks are prevented. 
        assert hasOAuthAccountAccess(sig)
```

#### SessionAccount Reproduction

The following pseudocode describes how we can reproduce a `SessionAccount` from the `OAuthAccountGUID` and `OAuthClientEntry` using an Indexer. The indexer is a tool designed to query blockchain data efficiently. With the latest transaction data at hand, one can extract the logic governing the authorizing account. Likewise, the base `SessionAccount`, which is setup after the user logs in using the `OAuthAccountGUID`, can be recreated whenever necessary as all its template variables are known. `OAuthAccountGUID` and `OAuthClientEntry` can be computed directly from the JWT, as explained above.

```python
defaultEphemeralKey = Bytes(16, "0xDEADBEEF")

def GetBaseAccount(
    OAuthAccountGUID,
    TenantAuthAppId
  ):
  return SessionAccount({
    TMPL_OAUTHACCOUNTGUID: OAuthAccountGUID,
    TMPL_EPK: defaultEphemeralKey, TMPL_EXP: 0,
    TMPL_TENANTAUTHAPPID: TenantAuthAppId
    })

def GetAuthorizingAccount(
    OAuthAccountGUID,
    TenantAuthAppId
  ):
  # Get the last transaction of the authorizing address
  baseAccount = GetBaseAccount(OAuthAccountGUID, TenantAuthAppId)
  authorizingAddress = baseAccount['auth-addr']
  lastAuthTxn = Indexer.GetLastTxn(authorizingAddress)
  if lastAuthTxn == None:
    return GetBaseAccount(OAuthAccountGUID, TenantAuthAppId)
  # Get the template variables from the last transaction
  epk, exp, customClaimKey, tenantAuthAppId = ReadTemplateVariables(lastAuthTxn)
  return SessionAccount({
    TMPL_OAUTHACCOUNTGUID: OAuthAccountGUID,
    TMPL_EPK: epk, TMPL_EXP: exp,
    TMPL_TENANTAUTHAPPID: tenantAuthAppId
    })

def GetSessionAccount(
    OAuthAccountGUID,
    TenantAuthAppId
  ):
  return [
          GetBaseAccount(OAuthAccountGUID, TenantAuthAppId),
          GetAuthorizingAccount(OAuthAccountGUID, TenantAuthAppId),
        ]

def GetNewAuthorizingSessionAccount(
      OAuthAccountGUID,
      TenantAuthAppId,
      epk,
      exp
    ):
    return SessionAccount({
      TMPL_OAUTHACCOUNTGUID: OAuthAccountGUID,
      TMPL_EPK: epk, TMPL_EXP: exp,
      TMPL_TENANTAUTHAPPID: tenantAuthAppId
      })
```

### Account Creation

There is nothing unique about account creation, except for the sending of a recovery email which a user can use to prove account ownership using ZK-Email for recovery purposes. The recovery process is to be refined in a future version of Zorkin, and is left as future work.

### Authorize a new Session

To initiate a new session, the procedure commences by creating a temporary, time-limited authorizing SessionAccount from a pre-existing base SessionAccount. Control over the base account is established by requiring each transaction to include a signature for the transaction ID. This ID is derived from the ephemeral private key, which pairs with the corresponding public key held in the authorizing LSIG as a template variable. To authorize the session, it is critical to provide a valid JWT OAuth access token obtained from the issuer's platform. This token is associated with the user through an `OAuthAccountGUID` and must authenticate access for the OAuth client marked by the `OAuthClientEntry`. The `OAuthClientEntry` is calculated using the Poseidon hash of the issuer and audience fields within the JWT, as well as the `CustomClaimKey`, which identifies the value in the JWT payload (`CustomClaimValue`).

The `CustomClaimValue` is a hash of the ephemeral private key and its expiration timestamp. To prevent replay attacks and ensure the transaction ID's distinctiveness within its valid period, a unique random lease value is incorporated. A group transaction is executed to perform various verification operations, such as Zero-Knowledge proof checks, which collectively confirm the authorization as described in the previously defined components. There are constraints that limit our ability to combine all components; for instance, the proof verification that requires excessive operational code budgets, and the necessity for the SessionAccount to function as a standard account by representing it as an LSIG contract account, among other limitations.
\
\
The procedure is the following:
1. Create a new ED25519 keypair to be used as the ephemeral key, denoting the public key as `epk` and the private key as `esk`. Define an expiration time `exp` for the new authorizing SessionAccount.
2. Acquire a JWT from an OAuth2 provider (e.g., Google) via the OAuth2/OpenID Connect protocol. The JWT should include a `CustomClaimValue` that equals `Sha256(epk, exp)`, all signed with the provider's RSA public key (`RSAPublicKey`).
3. Calculate the `OAuthAccountGUID` by applying the Poseidon hash to the OAuth2 provider's issuer identifier (`jwt.iss`) and the user identifier (`jwt.sub`).
4. Compute the `OAuthClientEntry` by hashing the issuer identifier (`jwt.iss`), the OAuth2 client identifier (`jwt.aud`), and `CustomClaimKey` using the Poseidon hash.
5. Generate a `proof` and `publicInput` by using a prover that takes the JWT `RSAPublicKey` and `CustomClaimKey` as private inputs, and `MIMCHash(OAuthAccountGUID, CustomClaimValue, RSAPublicKey, OAuthClientEntry)` as the public input.
6. Access the base SessionAccount along with the appropriate authorizing SessionAccount by calling `GetSessionAccount` with `OAuthAccountGUID` and `OAuthClientEntry` and the application ID for `TenantAuth`.
7. Establish a new authorizing SessionAccount using the `epk` and `exp` through the `GetNewAuthorizingSessionAccount` function, which will then update the base SessionAccount to use this new authorizing SessionAccount. Access to the base account will require the `epk` and `exp`.
8. Arrange a set of transactions named the Session Authorizing Transaction, which comprises:
    a. Transaction 0: An application call to `TenantAuth` to perform the `ApproveSession` function, controlled and signed by the `FeeFunder` LSIG to handle the group's fees. Provide `TenantAuth` application ID to `FeeFunder` via `TMPL_TENANTAUTHAPPID`.
    b. Transaction 1: A zero-value payment to oneself targeting `ProofVerifier` with `proof` as the argument and `publicInput` in the note field facilitating inter-transaction communication.
    c. Transaction 2: An application call to the `ValidateOAuthRSAPublicKey` function of the`RSAVerifier` application, including the `RSAPublicKey` as the application argument.
    d. Transaction 3: A transaction to update the base SessionAccount with the new authorizing SessionAccount, signed by the LSIG of the current authorizing SessionAccount. This transaction note should list `epk`, `exp`, `RSAPublicKey`, `OAuthAccountGUID`, and `OAuthClientEntry`. The transaction ID, signed with `esk`, and a random lease value are used as LSIG arguments to stop replay attacks and maintain transaction distinctiveness even within the same validity range.


![CredentialCreation](./images/AuthorizingASession.png)


### Transacting within an Authorized Session

Once a session has been authorized, the user is able to perform transactions from the SessionAccount. For a transaction to be considered valid, its Id must be signed with the ephemeral private key `esk` associated with the authorizing SessionAccount. This signature is included as an input argument to the authorizing SessionAccount's LogicSig (LSIG), which then serves as the signing authority for the transaction. The completed transaction, signed by the authorizing SessionAccount LSIG, can then be submitted to the blockchain network.

Procedure:
0. Calculate the `OAuthAccountGUID` by applying the Poseidon hash to the OAuth2 provider's issuer identifier (`jwt.iss`) and the user identifier (`jwt.sub`).
1. Compute the `OAuthClientEntry` by hashing the issuer identifier (`jwt.iss`), the OAuth2 client identifier (`jwt.aud`), and `CustomClaimKey` using the Poseidon hash.
2. Reproduce the base SessionAccount and its authorizing SessionAccount using the known `OAuthAccountGUID` and `OAuthClientEntry` by calling the `GetSessionAccount` function with these values as arguments. 
3. Create the desired transaction from the base SessionAccount, specified in the sender field of the transaction.
4. Assign a random value to the lease field to ensure the transaction ID is unique, and mutually exclusive until the lease expires.
5. Sign the tranasction Id with the ephemeral private key `esk` of the authorizing SessionAccount, and add the signature as an argument to the authorizing SessionAccount LSIG.
6. Sign the transaction with the authorizing SessionAccount LSIG.
7. Submit the transaction to the network.


![NativeGeneral](./images/SigningInASession.png)


### Account Recovery

To simplify, account recovery in Zorkin, not previously mentioned, involves adding a recovery factor to the SessionAccount for access restoration, like if a client goes offline. A proposed recovery method is using [ZK-Email](https://prove.email/) to send a recovery email at account creation. The user then verifies access to this email, linked to the SessionAccount through elements like the DKIM email signature RSA public key and a hash of their email address as template variables.

### Proof Generation Deferral

Proof generation by a remote prover, which can be resource-intensive, is postponed until required for signing to optimize costs and loading times. This enhances user experience, as many dApp users, like those browsing an NFT marketplace, don't necessarily transact. Once generated, a proof needs only a single verification for session establishment (i.e., rekeying), allowing subsequent spending without further proof production or verification until expiration, thereby reducing authentication fees and prover server costs.

## Differentiation & Improvements to Existing Work

- Zorkin advances the state of similar authentication technology in several ways when compared to existing solutions such as Sui's ZK-Login and the Snark-JWT-Verify library. Here are the key improvements made by Zorkin more clearly explained:

1. **Elimination of Salting Service Dependency**: Zorkin removes the dependency on a salting service for security purposes. Salting services add a layer of complexity and pose a potential vulnerability; if the salting service is compromised, it could lead to the loss of access to accounts. Furthermore, relying solely on a salting service does not mitigate the risk associated with an OAuth2 provider directly accessing accounts, as they have the authority to issue valid JWTs by design.

2. **Reduced Proof Verifications**: Another significant enhancement Zorkin offers is minimizing the frequency of proof verifications required for transaction authorization. By creating a trusted session that lasts for several hours, users do not need to generate new proofs for every transaction during that session. This reduction in verification needs leads to lower transaction fees and a smoother user experience.

3. **Deferred Proof Generation**: In line with providing a better user experience, Zorkin defers the generation of cryptographic proofs until the point when they are actually needed, such as when authorizing transactions. This approach relieves the server from the computational demands of generating proofs for every user upon log-in, especially beneficial when many users may not engage in transactions immediately. By deferring this intensive process, Zorkin ensures faster application loading times and optimizes resource utilization.

4. **Enhanced Flexibility with Authentication Providers**: Existing systems often depend on the ability to define a 'nonce' claim during the OAuth2 request to set up the ephemeral key. This presents a limitation because not all authentication solutions—like Firebase—allow programmatic control over user-definable claims. Zorkin's implementation uses a `CustomClaim`, which is a more flexible approach that is not restricted to a specific claim like 'nonce'. Hence, Zorkin's design allows it to work with a broader range of authentication providers that may not offer the same level of claim customization.

5. **Revocation of Active Sessions**: Zorkin allows users to revoke any active session by rekeying the SessionAccount back to the base SessionAccount, either using the ephemeral key itself, or remotely making use of the hardcoded creator public key which allows only the creator to revoke the session. This is useful in the event of SessionAccount loss of access for any reason, such as a malicious takeover or simply as a safety measure to prevent long range attacks that might utilise an old unexpired Session key.

These improvements focus on enhancing security, reducing costs, and offering a more adaptable and user-friendly authentication mechanism suitable for a variety of applications and authentication services.

## Future Work

We plan to enhance our methodology with the following initiatives:

1. Improve the Zero-Knowledge Email (ZK-Email) recovery process.
2. Ensure rekeying is only permitted for SessionAccount instances associated with the same OAuth account, to enhance security.
3. Explore strategies for offloading computation from the prover server by increasing the use of on-chain verifications.
4. Investigate methods to streamline the user experience, particularly with regards to the Algorand 'Opt-In' procedure for receiving an asset and addressing issues related to the Minimum Balance Requirement (MBR) that is necessary when opting in to receive an asset on the Algorand blockchain.

We have already established a technique for restricting rekeying. This approach involves generating the program code on-chain by inputting the specific parameters during a rekey transaction. This code is then hashed to generate an address. By comparing this address with the address in the rekey field, we can confirm if the rekeying is targeting a legitimate session account.

## Contribution Statement

Authored by Winton Nathan-Roberts of Sydney, Australia, this document details original work distinct from existing literature to the best of my knowledge. Novel contributions include its approach in implementing OAuth2 self-custodial access by recursively regenerating and rekeying SessionAccount LSIGs, the elimination of a salting service, proof generation deferral, decentralized recovery options and reduction in gas fees associated with constant proof verification. Thanks to the Algorand community for their support.
\
\
All Rights Reserved with Copyright.

## Disclaimer

This content, including texts, graphics, code, etc., is for informational purposes and provided 'as is' without guarantees.

- NO WARRANTIES: We offer no warranties or guarantees, explicit or implied.
- NO LIABILITY: We are not liable for any damages from using or inability to use this content.
- INDEPENDENCE: We do not necessarily have a direct affiliation with any party mentioned or implied besides Zorkin.
- INDEMNIFICATION: You must defend and indemnify us against all claims and damages from your use of the content.
- NOT PRODUCTION READY: The content may have vulnerabilities and is not for production use.
- USE AT YOUR OWN RISK: You are solely responsible for using the content and ensuring its legal compliance.
- UNVERIFIED CLAIMS: Claims in the content are not independently verified; do your own research before relying on them.

This disclaimer is applied to the fullest extent permitted by law. By using the content, you accept these terms. Note: This disclaimer was assisted by AI and I am not a legal professional. TLDR: it's an idea and an MVP, that I may or may not continue to work on at my discretion. Everything is subject to change, including the name.
